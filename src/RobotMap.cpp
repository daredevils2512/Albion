// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

//access pointer objects declared in RobotMap.h file
std::shared_ptr<CANTalon> RobotMap::drivetrainFrontLeftMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainRearLeftMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainFrontRightMotor;
std::shared_ptr<CANTalon> RobotMap::drivetrainRearRightMotor;
std::shared_ptr<frc::RobotDrive> RobotMap::drivetrainchassis;
std::shared_ptr<frc::Encoder> RobotMap::drivetrainLeftEncoder;
std::shared_ptr<frc::Encoder> RobotMap::drivetrainRightEncoder;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::shooterSolenoid;
std::shared_ptr<CANTalon> RobotMap::shooterMotor;
std::shared_ptr<frc::DigitalInput> RobotMap::shooterPhotoeye;
std::shared_ptr<frc::DoubleSolenoid> RobotMap::intakeSolenoid;
std::shared_ptr<CANTalon> RobotMap::intakeMotor;


//runs on startup of the robot
void RobotMap::init() {
	//assign ports and settings to pointer objects declared in RobotMap.h
    frc::LiveWindow *lw = frc::LiveWindow::GetInstance();

    drivetrainFrontLeftMotor.reset(new CANTalon(4));
    lw->AddActuator("Drivetrain", "FrontLeftMotor", drivetrainFrontLeftMotor);
    
    drivetrainRearLeftMotor.reset(new CANTalon(6));
    lw->AddActuator("Drivetrain", "RearLeftMotor", drivetrainRearLeftMotor);
    
    drivetrainFrontRightMotor.reset(new CANTalon(0));
    lw->AddActuator("Drivetrain", "FrontRightMotor", drivetrainFrontRightMotor);
    
    drivetrainRearRightMotor.reset(new CANTalon(8));
    lw->AddActuator("Drivetrain", "RearRightMotor", drivetrainRearRightMotor);
    
    drivetrainchassis.reset(new frc::RobotDrive(drivetrainFrontLeftMotor, drivetrainRearLeftMotor,
              drivetrainFrontRightMotor, drivetrainRearRightMotor));
    
    drivetrainchassis->SetSafetyEnabled(false);
        drivetrainchassis->SetExpiration(0.5);
        drivetrainchassis->SetSensitivity(0.5);
        //drivetrainchassis->SetMaxOutput(0.65);


    drivetrainLeftEncoder.reset(new frc::Encoder(0, 1, false, frc::Encoder::k4X));
    	lw->AddSensor("Drivetrain", "LeftEncoder", drivetrainLeftEncoder);
    drivetrainLeftEncoder->SetDistancePerPulse(0.0153846154);
    drivetrainLeftEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);
    drivetrainRightEncoder.reset(new frc::Encoder(2, 3, false, frc::Encoder::k4X));
    	lw->AddSensor("Drivetrain", "RightEncoder", drivetrainRightEncoder);
    drivetrainRightEncoder->SetDistancePerPulse(0.0153846154);
    drivetrainRightEncoder->SetPIDSourceType(frc::PIDSourceType::kRate);

    shooterSolenoid.reset(new frc::DoubleSolenoid(1, 0, 1));
        lw->AddActuator("Shooter", "Solenoid", shooterSolenoid);

        shooterMotor.reset(new CANTalon(9));
        lw->AddActuator("Shooter", "Motor", shooterMotor);

        shooterPhotoeye.reset(new frc::DigitalInput(5));
        lw->AddSensor("Shooter", "Photoeye", shooterPhotoeye);

        intakeSolenoid.reset(new frc::DoubleSolenoid(1, 2, 3));
        lw->AddActuator("Intake", "Solenoid", intakeSolenoid);

        intakeMotor.reset(new CANTalon(3));
        lw->AddActuator("Intake", "Motor", intakeMotor);

}
